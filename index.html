<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet" />
    <script src="https://unpkg.com/typewriter-effect@latest/dist/core.js"></script>
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
      rel="stylesheet"
    />
    <title>Finsai Bull</title>
    <link rel="stylesheet" href="css/style.css" />
  </head>
  <body>
    <div class="el"></div>
    <header>
      <div class="container">
        <nav class="d-flex justify-content-between">
          <div class="logo">
            <img src="images/logo-bull.png" width="90px" alt="">
          </div>
          <div class="menu-icon" onclick="toggleMenu()">&#9776;</div>
          <!-- Hamburger Icon -->
          <div class="menu">
            <ul class="d-flex align-items-center">
              <li><a href="#features">Features</a></li>
              <li><a href="#rewards">Rewards</a></li>
              <li><a href="#earn" class="secondary-btn">Refer & Earn</a></li>
            </ul>
            <div class="close-icon" onclick="toggleMenu()">&#10005;</div>
            <!-- Close Icon -->
          </div>
        </nav>
      </div>
    </header>

  <!-- Countdown Banner -->
  <div class="countdown-banner">
    <div class="banner-content">
      <h1>Bull-ieve it or not, we're coming soon!</h1>
      <div class="countdown">
        <div class="time">
          <span id="days">00</span>
          <p>Days</p>
        </div>
        <div class="time">
          <span id="hours">00</span>
          <p>Hours</p>
        </div>
        <div class="time">
          <span id="minutes">00</span>
          <p>Minutes</p>
        </div>
        <div class="time">
          <span id="seconds">00</span>
          <p>Seconds</p>
        </div>
      </div>
    </div>
  </div>

    <section class="hero-section">

     
      <div class="header-container">
        <div class="hero-content">


          

          <div class="hero-title px-12">
            <div id="animation-container">
              <h1 class="animated-heading">Tap, Earn & Rule the Bull Kingdom!</h1>
              
              <!-- <div id="cursor"></div> -->
            </div>
          </div>
          <img
            src="images/hero.webp"
            alt="animation-video"
            class="hero-gif d-block d-lg-none pt-20 pt-lg-0"
          />
          <div class="hero-detail px-12 px-lg-0" data-aos="fade-up">
            <div class="sub-heading">
              Relax, Play, Earn — Rewards Pile Up While You Build Your Bull
              Empire!
            </div>
            <a href="https://t.me/finsaibull_bot" class="primary-btn">Start Tapping, Start Earning!</a>
          </div>
        </div>
      </div>
      <img
        src="images/hero.webp"
        alt="animation-video"
        class="hero-gif d-none d-lg-block"
      />
    </section>
    <section class="cards-section padding-top padding-bottom" id="features">
      <div class="container">
        <h2 class="text-center" data-aos="fade-up">
          <span class="sm-text"> How to Dominate the</span> <br />
          <div id="animation-container">
              <div class="animated-heading">Finsai Bull Universe?</div>
            </div>
        </h2>
        <div class="row">
          <div class="col col-lg-6 col-12 cards-margin" data-aos="fade-up">
            <div class="card">
              <img src="images/bullcoin.png" alt="trophy" class="card-floating-img" data-aos="fade-right">
              
              <div class="card-title" data-aos="fade-up">
                <span class="colored-text">Earn Bull Points</span> with Every
                <span class="tap">
                  Tap! <img src="images/humble.webp" alt="" class="humble"
                /></span>
              </div>
              <div class="card-content" data-aos="fade-up">
                Yep, it’s that easy. No intense strategy required. Just tap away
                and watch your bull points grow!
              </div>
            </div>
          </div>
          <div class="col col-lg-6 col-12 cards-margin" data-aos="fade-up">
            <div class="card">
              <img src="images/flashmodified.png" alt="" class="card-floating-img" data-aos="fade-right">
              <div class="card-title" data-aos="fade-up">
                <span class="colored-text">Feed the Bull</span> for
                <span class="tap"
                  >Boosts! <img src="images/boost.webp" alt="" class="smile"
                /></span>
              </div>
              <div class="card-content" data-aos="fade-up">
                 Feed your bull some magical boosters,
                and boom,<span class="colored-text"> extra Bull Points!</span>
                The more you feed, the more you earn.
              </div>
            </div>
          </div>
          <div class="col col-100 cards-margin full-width-card" data-aos="fade-up">
            <div class="card">
              <div class="d-flex justify-content-between align-items-center">
                <div class="col-35 text-center">
                  <img src="images/point.png" alt="" data-aos="fade-right">
                </div>
                <div class="col-60">
                  <div class="card-title" data-aos="fade-up">
                    Daily <span class="colored-text"> Rewards </span>&
                    Referrals!
                  </div>
                  <div class="card-content" data-aos="fade-up">
                    <p>
                      <i
                        >Log in daily to claim your generous rewards just by
                        signing in</i
                      >
                      — one quick tap, and they’re yours!
                    </p>
                    Oh, you can also
                    <span class="colored-text"> refer your friends </span> to
                    stack up even more rewards. <br />
                    Friends don’t let friends miss out on free perks!
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="col col-lg-6 cards-margin" data-aos="fade-up">
            <div class="card">
              <img src="images/trophy.png" alt="" class="card-floating-img" data-aos="fade-right">
              <div class="card-title" data-aos="fade-up">
                Instant
                <span class="colored-text tap">
                  Prizes!
                  <img src="images/sparkle.webp" alt="" class="sparkle" />
                </span>
              </div>
              <div class="card-content" data-aos="fade-up">
                We're not messing around with delayed rewards here. Earn Bull
                Points, complete your tasks and unlock your airdrops instantly
                like following our social media, inviting friends, and much
                more. There's always something exciting for you to do and earn!
              </div>
            </div>
          </div>
          <div class="col col-12 col-lg-6 cards-margin" data-aos="fade-up">
            <div class="card">
              <div class="image-container ">
                <img src="images/phone.png" alt="" class="card-floating-img img2" data-aos="fade-right">
                <img src="images/humble.webp" alt="" class="humble2">
              </div>
              <div class="card-title" data-aos="fade-up">
                Minimal Effort,
                <span class="colored-text tap">
                  Maximum Fun!
                  <img src="images/smile.gif" alt="" class="smile" />
                </span>
              </div>
              <div class="card-content" data-aos="fade-up">
                Let’s be honest: earning rewards has never been this
                effortless!. Less effort, more rewards—because that’s how we
                roll!
              </div>
            </div>
          </div>
        </div>
      </div>
      
    </section>
    <section class="text-with-image padding-top padding-bottom" id="rewards">
      <div class="container">
        <div class="row align-items-center position-relative z-2">
        <div class="col col-lg-6 all-align-center">
            <h2 data-aos="fade-up" class="mb-0">
              <div id="animation-container">
                <div class="animated-heading colored-text">Play More, Earn Fast -</div>
              </div>
              <div id="animation-container">
                <div class="animated-heading">It’s Bull Points Time!</div>
              </div>
            </h2>
            <div class="content col-md-10 col-lg-12 mx-auto" data-aos="fade-up">
              It's that simple: <span class="highlight-text">Log in</span>,
              <span class="highlight-text">tap the bull</span>, and
              <span class="highlight-text">collect points</span>. There's no
              overthinking it—just start tapping, and let the points flow!
              Whether it's Bull Points from daily logins, referrals, or social
              media tasks, we’ve got rewards coming at you from every angle.
            </div>
            <a href="https://t.me/finsaibull_bot" class="primary-btn" data-aos="fade-up"
              >Start Collecting Your Rewards Now!</a
            >
          </div>
          <div class="col col-lg-6">
            <img
              src="images/scene2.webp"
              alt=""
              class="w-100 gif-2"
            />
          </div>
        </div>
      </div>
    </section>
    <section class="earn-section padding-top padding-bottom" id="earn">
      <div class="container">
        <div class="row position-relative z-2">
          <div class="col col-lg-6">
            <img
              src="images/scene3.webp"
              alt=""
              class="gif-2"
            />
          </div>
          <div class="col col-lg-6 d-flex justify-content-center flex-column all-align-center">
            <div class="pt-0">
              <h2 data-aos="fade-up" >
                <div id="animation-container">
                  <div class="animated-heading colored-text">Refer & Earn -</div>
                </div>
                <div id="animation-container">
                  <div class="animated-heading">Unlock Your Rewards!</div>
                </div>
              </h2>
              <div class="content col-md-10 col-lg-12 mx-auto" data-aos="fade-up">
                Invite your friends, tap into the action, and collect Bull Points
                & Keys for each referral. It's that easy – more friends, more
                rewards!
              </div>
              <a href="https://t.me/finsaibull_bot" class="primary-btn" data-aos="fade-up"
                >Start Referring Now!</a
              >
            </div>
          </div>
        </div>
      </div>
    </section>
    <section class="roadmap padding-top padding-bottom">
      <div class="container">
        <div class="roadmap-box">
          <div class="row">
            <div class="col col-100">
              <h2 data-aos="fade-up">
                <span class="sm-text typing-container"
                  >Thinking about the project
                  <span class="colored-text"> Roadmap!</span> <br
                /></span>
                <div id="animation-container">
                  <div class="animated-heading">What’s next?</div>
                </div>
              </h2>
              <h2 data-aos="fade-up">
                <div id="animation-container">
                  <div class="animated-heading">Trust us you’ll want to stay tuned</div>
                </div>
              </h2>
            </div>
          </div>
          <div class="row roadmap-bottom-row">
            <div class="col col-lg-6">
              <img src="images/mysterybox.webp" alt="" class="box" data-aos="fade-up"/>
            </div>
            <div class="col col-lg-6 d-flex align-items-center">
              <div class="roadmap-content" data-aos="fade-up">
                <div class="content">
                  We’ve got some exciting surprises in store, but we’re keeping
                  them under wraps for now! More tapping, more rewards, and even
                  crazier features are on the horizon. Stay tuned—you won’t want
                  to miss out!
                </div>
                <div class="pt-2">
                  <a href="https://t.me/finsaibull_bot" class="primary-btn"
                    >Keep Playing. Keep Earning
                  </a>
                </div>
              </div>
            </div>
          </div>
          <!-- <video autoplay muted loop playsinline class="background-video">
            <source src="images/square.mp4" type="video/mp4" /> -->
          </video>
        </div>
      </div>
    </section>


    <div id="contact-us" class="contact-us-container">
      <h2>Contact Us</h2>
      <form class="contact-form" action="contact.php" method="POST">
        <div class="form-group">
          <label for="first-name">Full Name</label>
          <input type="text" id="first-name" name="fullname" placeholder="Enter your full name" required>
        </div>
        <div class="form-group">
          <label for="user-id">Player ID</label>
          <input type="text" id="user-id" name="playerid" placeholder="Enter your user ID" required>
        </div>
        <div class="form-group">
          <label for="email">Email</label>
          <input type="email" id="email" name="email" placeholder="Enter your email address" required>
        </div>
        <div class="form-group">
          <label for="message">Subject/Message</label>
          <textarea id="message" name="message" placeholder="Enter your Message" maxlength="500" required></textarea>
        </div>
        <button type="submit" class="submit-btn">Submit</button>
      </form>
    </div>
    


    <footer class="footer">
      <div class="container">
        <div
          class="d-flex align-items-center footer-aligns"
        >

       
        
          <div>
            <ul class="d-flex align-items-center">
              <li><a href="#features">Features</a></li>
              <li><a href="#rewards">Rewards</a></li>
              <li><a href="#earn">Refer & Earn</a></li>
            </ul>
          </div>
          <div class="d-none d-lg-block">
            <div class="d-flex align-items-center gap-1">
              <svg
                width="18"
                height="19"
                viewBox="0 0 18 19"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M7.56 8.645C7.5975 8.3975 7.68 8.18 7.785 7.9925C7.89 7.805 8.04 7.6475 8.2275 7.5275C8.4075 7.415 8.6325 7.3625 8.91 7.355C9.0825 7.3625 9.24 7.3925 9.3825 7.4525C9.5325 7.52 9.6675 7.61 9.7725 7.7225C9.8775 7.835 9.96 7.97 10.0275 8.12C10.095 8.27 10.125 8.435 10.1325 8.6H11.475C11.46 8.2475 11.3925 7.925 11.265 7.6325C11.1375 7.34 10.965 7.085 10.74 6.875C10.515 6.665 10.245 6.5 9.93 6.38C9.615 6.26 9.27 6.2075 8.8875 6.2075C8.4 6.2075 7.9725 6.29 7.6125 6.4625C7.2525 6.635 6.9525 6.86 6.7125 7.1525C6.4725 7.445 6.2925 7.7825 6.18 8.1725C6.0675 8.5625 6 8.9675 6 9.4025V9.605C6 10.04 6.06 10.445 6.1725 10.835C6.285 11.225 6.465 11.5625 6.705 11.8475C6.945 12.1325 7.245 12.365 7.605 12.53C7.965 12.695 8.3925 12.785 8.88 12.785C9.2325 12.785 9.5625 12.725 9.87 12.6125C10.1775 12.5 10.4475 12.3425 10.68 12.14C10.9125 11.9375 11.1 11.705 11.235 11.435C11.37 11.165 11.4525 10.88 11.46 10.5725H10.1175C10.11 10.73 10.0725 10.8725 10.005 11.0075C9.9375 11.1425 9.8475 11.255 9.735 11.3525C9.6225 11.45 9.495 11.525 9.345 11.5775C9.2025 11.63 9.0525 11.645 8.895 11.6525C8.625 11.645 8.4 11.5925 8.2275 11.48C8.04 11.36 7.89 11.2025 7.785 11.015C7.68 10.8275 7.5975 10.6025 7.56 10.355C7.5225 10.1075 7.5 9.8525 7.5 9.605V9.4025C7.5 9.14 7.5225 8.8925 7.56 8.645ZM9 2C4.86 2 1.5 5.36 1.5 9.5C1.5 13.64 4.86 17 9 17C13.14 17 16.5 13.64 16.5 9.5C16.5 5.36 13.14 2 9 2ZM9 15.5C5.6925 15.5 3 12.8075 3 9.5C3 6.1925 5.6925 3.5 9 3.5C12.3075 3.5 15 6.1925 15 9.5C15 12.8075 12.3075 15.5 9 15.5Z"
                  fill="white"
                />
              </svg>
              <p class="content">Finsai Bull</p>
            </div>
          </div>
          <div class="d-flex align-items-center icons-gap">
            <a href="https://t.me/finsaibullannouncements" target="_blank" class="icons">
              <i class="fab fa-telegram"></i>
            </a>
            <a href="https://x.com/Finsaibull?mx=2" target="_blank" class="icons">
              <i class="fab fa-twitter"></i>
            </a>
            <a href="https://www.instagram.com/finsaibull/" target="_blank" class="icons">
              <i class="fab fa-instagram"></i>
              <a href="https://www.youtube.com/@FinsaiBull" target="_blank" class="icons">
                <i class="fab fa-youtube"></i>
            <a href="https://www.facebook.com/people/Finsai-Bull/61566481749538/" target="_blank" class="icons">
              <i class="fab fa-facebook"></i>
            </a>
            
            </a>
            
          </div>
          <div class="d-block d-lg-none">
            <div class="d-flex align-items-center gap-1">
              <svg
                width="18"
                height="19"
                viewBox="0 0 18 19"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M7.56 8.645C7.5975 8.3975 7.68 8.18 7.785 7.9925C7.89 7.805 8.04 7.6475 8.2275 7.5275C8.4075 7.415 8.6325 7.3625 8.91 7.355C9.0825 7.3625 9.24 7.3925 9.3825 7.4525C9.5325 7.52 9.6675 7.61 9.7725 7.7225C9.8775 7.835 9.96 7.97 10.0275 8.12C10.095 8.27 10.125 8.435 10.1325 8.6H11.475C11.46 8.2475 11.3925 7.925 11.265 7.6325C11.1375 7.34 10.965 7.085 10.74 6.875C10.515 6.665 10.245 6.5 9.93 6.38C9.615 6.26 9.27 6.2075 8.8875 6.2075C8.4 6.2075 7.9725 6.29 7.6125 6.4625C7.2525 6.635 6.9525 6.86 6.7125 7.1525C6.4725 7.445 6.2925 7.7825 6.18 8.1725C6.0675 8.5625 6 8.9675 6 9.4025V9.605C6 10.04 6.06 10.445 6.1725 10.835C6.285 11.225 6.465 11.5625 6.705 11.8475C6.945 12.1325 7.245 12.365 7.605 12.53C7.965 12.695 8.3925 12.785 8.88 12.785C9.2325 12.785 9.5625 12.725 9.87 12.6125C10.1775 12.5 10.4475 12.3425 10.68 12.14C10.9125 11.9375 11.1 11.705 11.235 11.435C11.37 11.165 11.4525 10.88 11.46 10.5725H10.1175C10.11 10.73 10.0725 10.8725 10.005 11.0075C9.9375 11.1425 9.8475 11.255 9.735 11.3525C9.6225 11.45 9.495 11.525 9.345 11.5775C9.2025 11.63 9.0525 11.645 8.895 11.6525C8.625 11.645 8.4 11.5925 8.2275 11.48C8.04 11.36 7.89 11.2025 7.785 11.015C7.68 10.8275 7.5975 10.6025 7.56 10.355C7.5225 10.1075 7.5 9.8525 7.5 9.605V9.4025C7.5 9.14 7.5225 8.8925 7.56 8.645ZM9 2C4.86 2 1.5 5.36 1.5 9.5C1.5 13.64 4.86 17 9 17C13.14 17 16.5 13.64 16.5 9.5C16.5 5.36 13.14 2 9 2ZM9 15.5C5.6925 15.5 3 12.8075 3 9.5C3 6.1925 5.6925 3.5 9 3.5C12.3075 3.5 15 6.1925 15 9.5C15 12.8075 12.3075 15.5 9 15.5Z"
                  fill="white"
                />
              </svg>
              <p class="content">Finsai Bull</p>
            </div>
          </div>
        </div>
      </div>
    </footer>
    <!-- <div class="el"></div> -->
    

    <!-- <div class="ripple-1"></div>
    <div class="ripple-2"></div>
    <div class="ripple-3"></div>
    <div class="ripple-4"></div>
    <div class="ripple-5"></div> -->
   
    <!-- <span class="ripple"></span> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/browser/pixi.min.js"></script>
    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12"></script>

    <script>
      function toggleMenu() {
        const menu = document.querySelector(".menu");
        menu.classList.toggle("show");
      }
    </script>

    <script>
      AOS.init({
        duration: 1000,
        debounceDelay: 50,
        once: false,
        mirror: true,
      });
    </script>

    <!-- <script>
      const coords = { x: 0, y: 0 };
      const circles = document.querySelectorAll(".circle");

      const colors = [
        "#B3841A",
        "#B3841A",
        "#C99A30",
        "#C99A30",
        "#DBAC42",
        "#DBAC42",
        "#DBAC42",
        "#EFC056",
        "#EFC056",
        "#EFC056",
        "#EFC056",
        "#EFC056",
        "#F3C45A",
        "#F3C45A",
        "#F3C45A",
        "#F3C45A",
        "#FCCD63",
        "#FCCD63",
        "#FCCD63",
        "#FCCD63",
        "#FFD56B",
        "#FFD56B",
      ];

      circles.forEach(function (circle, index) {
        circle.x = 0;
        circle.y = 0;
        circle.style.backgroundColor = colors[index % colors.length];
      });

      window.addEventListener("mousemove", function (e) {
        coords.x = e.clientX;
        coords.y = e.clientY;
      });

      function animateCircles() {
        let x = coords.x;
        let y = coords.y;

        circles.forEach(function (circle, index) {
          circle.style.left = x - 12 + "px";
          circle.style.top = y - 12 + "px";

          circle.style.scale = (circles.length - index) / circles.length;

          circle.x = x;
          circle.y = y;

          const nextCircle = circles[index + 1] || circles[0];
          x += (nextCircle.x - x) * 0.3;
          y += (nextCircle.y - y) * 0.3;
        });

        requestAnimationFrame(animateCircles);
      }

      animateCircles();
    </script> -->
    <script>
      var app = document.getElementById("app");

      var Typewriter = new Typewriter(app, {
        loop: true,
        delay: 75,
        backspace: false,
        backspace: false,
      });

      Typewriter.pauseFor(300)
        .typeString("Tap, Earn & Rule")
        .pauseFor(300)
        .typeString('<span class="sm-text"> the</span>')
        .typeString('<span class="colored-text"> Bull <br/>Kingdom!</span>')
        .pauseFor(1000)
        .start();
    </script>
    <!-- <script>
              "use strict";

              const canvas = document.getElementsByTagName("canvas")[0];
              canvas.width = canvas.clientWidth;
              canvas.height = canvas.clientHeight;

              let config = {
                TEXTURE_DOWNSAMPLE: 1,
                DENSITY_DISSIPATION: 0.98,
                VELOCITY_DISSIPATION: 0.99,
                PRESSURE_DISSIPATION: 0.8,
                PRESSURE_ITERATIONS: 25,
                CURL: 28,
                SPLAT_RADIUS: 0.004,
              };

              let pointers = [];
              let splatStack = [];

              const { gl, ext } = getWebGLContext(canvas);

              function getWebGLContext(canvas) {
                const params = {
                  alpha: false,
                  depth: false,
                  stencil: false,
                  antialias: false,
                };

                let gl = canvas.getContext("webgl2", params);
                const isWebGL2 = !!gl;
                if (!isWebGL2)
                  gl =
                    canvas.getContext("webgl", params) ||
                    canvas.getContext("experimental-webgl", params);

                let halfFloat;
                let supportLinearFiltering;
                if (isWebGL2) {
                  gl.getExtension("EXT_color_buffer_float");
                  supportLinearFiltering = gl.getExtension("OES_texture_float_linear");
                } else {
                  halfFloat = gl.getExtension("OES_texture_half_float");
                  supportLinearFiltering = gl.getExtension(
                    "OES_texture_half_float_linear"
                  );
                }

                gl.clearColor(0.0, 0.0, 0.0, 1.0);

                const halfFloatTexType = isWebGL2
                  ? gl.HALF_FLOAT
                  : halfFloat.HALF_FLOAT_OES;
                let formatRGBA;
                let formatRG;
                let formatR;

                if (isWebGL2) {
                  formatRGBA = getSupportedFormat(
                    gl,
                    gl.RGBA16F,
                    gl.RGBA,
                    halfFloatTexType
                  );
                  formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);
                  formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);
                } else {
                  formatRGBA = getSupportedFormat(
                    gl,
                    gl.RGBA,
                    gl.RGBA,
                    halfFloatTexType
                  );
                  formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
                  formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
                }

                return {
                  gl,
                  ext: {
                    formatRGBA,
                    formatRG,
                    formatR,
                    halfFloatTexType,
                    supportLinearFiltering,
                  },
                };
              }

              function getSupportedFormat(gl, internalFormat, format, type) {
                if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {
                  switch (internalFormat) {
                    case gl.R16F:
                      return getSupportedFormat(gl, gl.RG16F, gl.RG, type);
                    case gl.RG16F:
                      return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);
                    default:
                      return null;
                  }
                }

                return {
                  internalFormat,
                  format,
                };
              }

              function supportRenderTextureFormat(gl, internalFormat, format, type) {
                let texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(
                  gl.TEXTURE_2D,
                  0,
                  internalFormat,
                  4,
                  4,
                  0,
                  format,
                  type,
                  null
                );

                let fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(
                  gl.FRAMEBUFFER,
                  gl.COLOR_ATTACHMENT0,
                  gl.TEXTURE_2D,
                  texture,
                  0
                );

                const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (status != gl.FRAMEBUFFER_COMPLETE) return false;
                return true;
              }

              function pointerPrototype() {
                this.id = -1;
                this.x = 0;
                this.y = 0;
                this.dx = 0;
                this.dy = 0;
                this.down = false;
                this.moved = false;
                this.color = [30, 0, 300];
              }

              pointers.push(new pointerPrototype());

              class GLProgram {
                constructor(vertexShader, fragmentShader) {
                  this.uniforms = {};
                  this.program = gl.createProgram();

                  gl.attachShader(this.program, vertexShader);
                  gl.attachShader(this.program, fragmentShader);
                  gl.linkProgram(this.program);

                  if (!gl.getProgramParameter(this.program, gl.LINK_STATUS))
                    throw gl.getProgramInfoLog(this.program);

                  const uniformCount = gl.getProgramParameter(
                    this.program,
                    gl.ACTIVE_UNIFORMS
                  );
                  for (let i = 0; i < uniformCount; i++) {
                    const uniformName = gl.getActiveUniform(this.program, i).name;
                    this.uniforms[uniformName] = gl.getUniformLocation(
                      this.program,
                      uniformName
                    );
                  }
                }

                bind() {
                  gl.useProgram(this.program);
                }
              }

              function compileShader(type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
                  throw gl.getShaderInfoLog(shader);

                return shader;
              }

              const baseVertexShader = compileShader(
                gl.VERTEX_SHADER,
                `
            precision highp float;
            precision mediump sampler2D;

            attribute vec2 aPosition;
            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform vec2 texelSize;

            void main () {
                vUv = aPosition * 0.5 + 0.5;
                vL = vUv - vec2(texelSize.x, 0.0);
                vR = vUv + vec2(texelSize.x, 0.0);
                vT = vUv + vec2(0.0, texelSize.y);
                vB = vUv - vec2(0.0, texelSize.y);
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `
              );

              const clearShader = compileShader(
                gl.FRAGMENT_SHADER,
                `
            precision highp float;
            precision mediump sampler2D;

            varying vec2 vUv;
            uniform sampler2D uTexture;
            uniform float value;

            void main () {
                gl_FragColor = value * texture2D(uTexture, vUv);
            }
        `
              );

              const displayShader = compileShader(
                gl.FRAGMENT_SHADER,
                `
            precision highp float;
            precision mediump sampler2D;

            varying vec2 vUv;
            uniform sampler2D uTexture;

            void main () {
                gl_FragColor = texture2D(uTexture, vUv);
            }
        `
              );

              const splatShader = compileShader(
                gl.FRAGMENT_SHADER,
                `
            precision highp float;
            precision mediump sampler2D;

            varying vec2 vUv;
            uniform sampler2D uTarget;
            uniform float aspectRatio;
            uniform vec3 color;
            uniform vec2 point;
            uniform float radius;

            void main () {
                vec2 p = vUv - point.xy;
                p.x *= aspectRatio;
                vec3 splat = exp(-dot(p, p) / radius) * color;
                vec3 base = texture2D(uTarget, vUv).xyz;
                gl_FragColor = vec4(base + splat, 1.0);
            }
        `
              );

              const advectionManualFilteringShader = compileShader(
                gl.FRAGMENT_SHADER,
                `
            precision highp float;
            precision mediump sampler2D;

            varying vec2 vUv;
            uniform sampler2D uVelocity;
            uniform sampler2D uSource;
            uniform vec2 texelSize;
            uniform float dt;
            uniform float dissipation;

            vec4 bilerp (in sampler2D sam, in vec2 p) {
                vec4 st;
                st.xy = floor(p - 0.5) + 0.5;
                st.zw = st.xy + 1.0;
                vec4 uv = st * texelSize.xyxy;
                vec4 a = texture2D(sam, uv.xy);
                vec4 b = texture2D(sam, uv.zy);
                vec4 c = texture2D(sam, uv.xw);
                vec4 d = texture2D(sam, uv.zw);
                vec2 f = p - st.xy;
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }

            void main () {
                vec2 coord = gl_FragCoord.xy - dt * texture2D(uVelocity, vUv).xy;
                gl_FragColor = dissipation * bilerp(uSource, coord);
                gl_FragColor.a = 1.0;
            }
        `
              );

              const advectionShader = compileShader(
                gl.FRAGMENT_SHADER,
                `
            precision highp float;
            precision mediump sampler2D;

            varying vec2 vUv;
            uniform sampler2D uVelocity;
            uniform sampler2D uSource;
            uniform vec2 texelSize;
            uniform float dt;
            uniform float dissipation;

            void main () {
                vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
                gl_FragColor = dissipation * texture2D(uSource, coord);
                gl_FragColor.a = 1.0;
            }
        `
              );

              const divergenceShader = compileShader(
                gl.FRAGMENT_SHADER,
                `
            precision highp float;
            precision mediump sampler2D;

            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform sampler2D uVelocity;

            vec2 sampleVelocity (in vec2 uv) {
                vec2 multiplier = vec2(1.0, 1.0);
                if (uv.x < 0.0) { uv.x = 0.0; multiplier.x = -1.0; }
                if (uv.x > 1.0) { uv.x = 1.0; multiplier.x = -1.0; }
                if (uv.y < 0.0) { uv.y = 0.0; multiplier.y = -1.0; }
                if (uv.y > 1.0) { uv.y = 1.0; multiplier.y = -1.0; }
                return multiplier * texture2D(uVelocity, uv).xy;
            }

            void main () {
                float L = sampleVelocity(vL).x;
                float R = sampleVelocity(vR).x;
                float T = sampleVelocity(vT).y;
                float B = sampleVelocity(vB).y;
                float div = 0.5 * (R - L + T - B);
                gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
            }
        `
              );

              const curlShader = compileShader(
                gl.FRAGMENT_SHADER,
                `
            precision highp float;
            precision mediump sampler2D;

            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform sampler2D uVelocity;

            void main () {
                float L = texture2D(uVelocity, vL).y;
                float R = texture2D(uVelocity, vR).y;
                float T = texture2D(uVelocity, vT).x;
                float B = texture2D(uVelocity, vB).x;
                float vorticity = R - L - T + B;
                gl_FragColor = vec4(vorticity, 0.0, 0.0, 1.0);
            }
        `
              );

              const vorticityShader = compileShader(
                gl.FRAGMENT_SHADER,
                `
            precision highp float;
            precision mediump sampler2D;

            varying vec2 vUv;
            varying vec2 vT;
            varying vec2 vB;
            uniform sampler2D uVelocity;
            uniform sampler2D uCurl;
            uniform float curl;
            uniform float dt;

            void main () {
                float T = texture2D(uCurl, vT).x;
                float B = texture2D(uCurl, vB).x;
                float C = texture2D(uCurl, vUv).x;
                vec2 force = vec2(abs(T) - abs(B), 0.0);
                force *= 1.0 / length(force + 0.00001) * curl * C;
                vec2 vel = texture2D(uVelocity, vUv).xy;
                gl_FragColor = vec4(vel + force * dt, 0.0, 1.0);
            }
        `
              );

              const pressureShader = compileShader(
                gl.FRAGMENT_SHADER,
                `
            precision highp float;
            precision mediump sampler2D;

            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform sampler2D uPressure;
            uniform sampler2D uDivergence;

            vec2 boundary (in vec2 uv) {
                uv = min(max(uv, 0.0), 1.0);
                return uv;
            }

            void main () {
                float L = texture2D(uPressure, boundary(vL)).x;
                float R = texture2D(uPressure, boundary(vR)).x;
                float T = texture2D(uPressure, boundary(vT)).x;
                float B = texture2D(uPressure, boundary(vB)).x;
                float C = texture2D(uPressure, vUv).x;
                float divergence = texture2D(uDivergence, vUv).x;
                float pressure = (L + R + B + T - divergence) * 0.25;
                gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
            }
        `
              );

              const gradientSubtractShader = compileShader(
                gl.FRAGMENT_SHADER,
                `
            precision highp float;
            precision mediump sampler2D;

            varying vec2 vUv;
            varying vec2 vL;
            varying vec2 vR;
            varying vec2 vT;
            varying vec2 vB;
            uniform sampler2D uPressure;
            uniform sampler2D uVelocity;

            vec2 boundary (in vec2 uv) {
                uv = min(max(uv, 0.0), 1.0);
                return uv;
            }

            void main () {
                float L = texture2D(uPressure, boundary(vL)).x;
                float R = texture2D(uPressure, boundary(vR)).x;
                float T = texture2D(uPressure, boundary(vT)).x;
                float B = texture2D(uPressure, boundary(vB)).x;
                vec2 velocity = texture2D(uVelocity, vUv).xy;
                velocity.xy -= vec2(R - L, T - B);
                gl_FragColor = vec4(velocity, 0.0, 1.0);
            }
        `
              );

              let textureWidth;
              let textureHeight;
              let density;
              let velocity;
              let divergence;
              let curl;
              let pressure;
              initFramebuffers();

              const clearProgram = new GLProgram(baseVertexShader, clearShader);
              const displayProgram = new GLProgram(baseVertexShader, displayShader);
              const splatProgram = new GLProgram(baseVertexShader, splatShader);
              const advectionProgram = new GLProgram(
                baseVertexShader,
                ext.supportLinearFiltering
                  ? advectionShader
                  : advectionManualFilteringShader
              );
              const divergenceProgram = new GLProgram(
                baseVertexShader,
                divergenceShader
              );
              const curlProgram = new GLProgram(baseVertexShader, curlShader);
              const vorticityProgram = new GLProgram(baseVertexShader, vorticityShader);
              const pressureProgram = new GLProgram(baseVertexShader, pressureShader);
              const gradienSubtractProgram = new GLProgram(
                baseVertexShader,
                gradientSubtractShader
              );

              function initFramebuffers() {
                textureWidth = gl.drawingBufferWidth >> config.TEXTURE_DOWNSAMPLE;
                textureHeight = gl.drawingBufferHeight >> config.TEXTURE_DOWNSAMPLE;

                const texType = ext.halfFloatTexType;
                const rgba = ext.formatRGBA;
                const rg = ext.formatRG;
                const r = ext.formatR;

                density = createDoubleFBO(
                  2,
                  textureWidth,
                  textureHeight,
                  rgba.internalFormat,
                  rgba.format,
                  texType,
                  ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST
                );
                velocity = createDoubleFBO(
                  0,
                  textureWidth,
                  textureHeight,
                  rg.internalFormat,
                  rg.format,
                  texType,
                  ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST
                );
                divergence = createFBO(
                  4,
                  textureWidth,
                  textureHeight,
                  r.internalFormat,
                  r.format,
                  texType,
                  gl.NEAREST
                );
                curl = createFBO(
                  5,
                  textureWidth,
                  textureHeight,
                  r.internalFormat,
                  r.format,
                  texType,
                  gl.NEAREST
                );
                pressure = createDoubleFBO(
                  6,
                  textureWidth,
                  textureHeight,
                  r.internalFormat,
                  r.format,
                  texType,
                  gl.NEAREST
                );
              }

              function createFBO(texId, w, h, internalFormat, format, type, param) {
                gl.activeTexture(gl.TEXTURE0 + texId);
                let texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(
                  gl.TEXTURE_2D,
                  0,
                  internalFormat,
                  w,
                  h,
                  0,
                  format,
                  type,
                  null
                );

                let fbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
                gl.framebufferTexture2D(
                  gl.FRAMEBUFFER,
                  gl.COLOR_ATTACHMENT0,
                  gl.TEXTURE_2D,
                  texture,
                  0
                );
                gl.viewport(0, 0, w, h);
                gl.clear(gl.COLOR_BUFFER_BIT);

                return [texture, fbo, texId];
              }

              function createDoubleFBO(
                texId,
                w,
                h,
                internalFormat,
                format,
                type,
                param
              ) {
                let fbo1 = createFBO(texId, w, h, internalFormat, format, type, param);
                let fbo2 = createFBO(
                  texId + 1,
                  w,
                  h,
                  internalFormat,
                  format,
                  type,
                  param
                );

                return {
                  get read() {
                    return fbo1;
                  },
                  get write() {
                    return fbo2;
                  },
                  swap() {
                    let temp = fbo1;
                    fbo1 = fbo2;
                    fbo2 = temp;
                  },
                };
              }

              const blit = (() => {
                gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
                gl.bufferData(
                  gl.ARRAY_BUFFER,
                  new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]),
                  gl.STATIC_DRAW
                );
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
                gl.bufferData(
                  gl.ELEMENT_ARRAY_BUFFER,
                  new Uint16Array([0, 1, 2, 0, 2, 3]),
                  gl.STATIC_DRAW
                );
                gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(0);

                return (destination) => {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, destination);
                  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                };
              })();

              let lastTime = Date.now();
              multipleSplats(parseInt(Math.random() * 20) + 5);
              update();

              function update() {
                resizeCanvas();

                const dt = Math.min((Date.now() - lastTime) / 1000, 0.016);
                lastTime = Date.now();

                gl.viewport(0, 0, textureWidth, textureHeight);

                if (splatStack.length > 0) multipleSplats(splatStack.pop());

                advectionProgram.bind();
                gl.uniform2f(
                  advectionProgram.uniforms.texelSize,
                  1.0 / textureWidth,
                  1.0 / textureHeight
                );
                gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read[2]);
                gl.uniform1i(advectionProgram.uniforms.uSource, velocity.read[2]);
                gl.uniform1f(advectionProgram.uniforms.dt, dt);
                gl.uniform1f(
                  advectionProgram.uniforms.dissipation,
                  config.VELOCITY_DISSIPATION
                );
                blit(velocity.write[1]);
                velocity.swap();

                gl.uniform1i(advectionProgram.uniforms.uVelocity, velocity.read[2]);
                gl.uniform1i(advectionProgram.uniforms.uSource, density.read[2]);
                gl.uniform1f(
                  advectionProgram.uniforms.dissipation,
                  config.DENSITY_DISSIPATION
                );
                blit(density.write[1]);
                density.swap();

                for (let i = 0; i < pointers.length; i++) {
                  const pointer = pointers[i];
                  if (pointer.moved) {
                    splat(pointer.x, pointer.y, pointer.dx, pointer.dy, pointer.color);
                    pointer.moved = false;
                  }
                }

                curlProgram.bind();
                gl.uniform2f(
                  curlProgram.uniforms.texelSize,
                  1.0 / textureWidth,
                  1.0 / textureHeight
                );
                gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read[2]);
                blit(curl[1]);

                vorticityProgram.bind();
                gl.uniform2f(
                  vorticityProgram.uniforms.texelSize,
                  1.0 / textureWidth,
                  1.0 / textureHeight
                );
                gl.uniform1i(vorticityProgram.uniforms.uVelocity, velocity.read[2]);
                gl.uniform1i(vorticityProgram.uniforms.uCurl, curl[2]);
                gl.uniform1f(vorticityProgram.uniforms.curl, config.CURL);
                gl.uniform1f(vorticityProgram.uniforms.dt, dt);
                blit(velocity.write[1]);
                velocity.swap();

                divergenceProgram.bind();
                gl.uniform2f(
                  divergenceProgram.uniforms.texelSize,
                  1.0 / textureWidth,
                  1.0 / textureHeight
                );
                gl.uniform1i(divergenceProgram.uniforms.uVelocity, velocity.read[2]);
                blit(divergence[1]);

                clearProgram.bind();
                let pressureTexId = pressure.read[2];
                gl.activeTexture(gl.TEXTURE0 + pressureTexId);
                gl.bindTexture(gl.TEXTURE_2D, pressure.read[0]);
                gl.uniform1i(clearProgram.uniforms.uTexture, pressureTexId);
                gl.uniform1f(clearProgram.uniforms.value, config.PRESSURE_DISSIPATION);
                blit(pressure.write[1]);
                pressure.swap();

                pressureProgram.bind();
                gl.uniform2f(
                  pressureProgram.uniforms.texelSize,
                  1.0 / textureWidth,
                  1.0 / textureHeight
                );
                gl.uniform1i(pressureProgram.uniforms.uDivergence, divergence[2]);
                pressureTexId = pressure.read[2];
                gl.uniform1i(pressureProgram.uniforms.uPressure, pressureTexId);
                gl.activeTexture(gl.TEXTURE0 + pressureTexId);
                for (let i = 0; i < config.PRESSURE_ITERATIONS; i++) {
                  gl.bindTexture(gl.TEXTURE_2D, pressure.read[0]);
                  blit(pressure.write[1]);
                  pressure.swap();
                }

                gradienSubtractProgram.bind();
                gl.uniform2f(
                  gradienSubtractProgram.uniforms.texelSize,
                  1.0 / textureWidth,
                  1.0 / textureHeight
                );
                gl.uniform1i(
                  gradienSubtractProgram.uniforms.uPressure,
                  pressure.read[2]
                );
                gl.uniform1i(
                  gradienSubtractProgram.uniforms.uVelocity,
                  velocity.read[2]
                );
                blit(velocity.write[1]);
                velocity.swap();

                gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                displayProgram.bind();
                gl.uniform1i(displayProgram.uniforms.uTexture, density.read[2]);
                blit(null);

                requestAnimationFrame(update);
              }

              function splat(x, y, dx, dy, color) {
                splatProgram.bind();
                gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read[2]);
                gl.uniform1f(
                  splatProgram.uniforms.aspectRatio,
                  canvas.width / canvas.height
                );
                gl.uniform2f(
                  splatProgram.uniforms.point,
                  x / canvas.width,
                  1.0 - y / canvas.height
                );
                gl.uniform3f(splatProgram.uniforms.color, dx, -dy, 1.0);
                gl.uniform1f(splatProgram.uniforms.radius, config.SPLAT_RADIUS);
                blit(velocity.write[1]);
                velocity.swap();

                gl.uniform1i(splatProgram.uniforms.uTarget, density.read[2]);
                gl.uniform3f(
                  splatProgram.uniforms.color,
                  color[0] * 0.3,
                  color[1] * 0.3,
                  color[2] * 0.3
                );
                blit(density.write[1]);
                density.swap();
              }

              function multipleSplats(amount) {
                for (let i = 0; i < amount; i++) {
                  const color = [
                    Math.random() * 10,
                    Math.random() * 10,
                    Math.random() * 10,
                  ];
                  const x = canvas.width * Math.random();
                  const y = canvas.height * Math.random();
                  const dx = 1000 * (Math.random() - 0.5);
                  const dy = 1000 * (Math.random() - 0.5);
                  splat(x, y, dx, dy, color);
                }
              }

              function resizeCanvas() {
                if (
                  canvas.width != canvas.clientWidth ||
                  canvas.height != canvas.clientHeight
                ) {
                  canvas.width = canvas.clientWidth;
                  canvas.height = canvas.clientHeight;
                  initFramebuffers();
                }
              }

              canvas.addEventListener("mousemove", (e) => {
                pointers[0].moved = pointers[0].down;
                pointers[0].dx = (e.offsetX - pointers[0].x) * 10.0;
                pointers[0].dy = (e.offsetY - pointers[0].y) * 10.0;
                pointers[0].x = e.offsetX;
                pointers[0].y = e.offsetY;
              });

              canvas.addEventListener(
                "touchmove",
                (e) => {
                  e.preventDefault();
                  const touches = e.targetTouches;
                  for (let i = 0; i < touches.length; i++) {
                    let pointer = pointers[i];
                    pointer.moved = pointer.down;
                    pointer.dx = (touches[i].pageX - pointer.x) * 10.0;
                    pointer.dy = (touches[i].pageY - pointer.y) * 10.0;
                    pointer.x = touches[i].pageX;
                    pointer.y = touches[i].pageY;
                  }
                },
                false
              );

              canvas.addEventListener("mousemove", () => {
                pointers[0].down = true;
                pointers[0].color = [
                  Math.random() + 0.2,
                  Math.random() + 0.2,
                  Math.random() + 0.2,
                ];
              });

              canvas.addEventListener("touchstart", (e) => {
                e.preventDefault();
                const touches = e.targetTouches;
                for (let i = 0; i < touches.length; i++) {
                  if (i >= pointers.length) pointers.push(new pointerPrototype());

                  pointers[i].id = touches[i].identifier;
                  pointers[i].down = true;
                  pointers[i].x = touches[i].pageX;
                  pointers[i].y = touches[i].pageY;
                  pointers[i].color = [
                    Math.random() + 0.2,
                    Math.random() + 0.2,
                    Math.random() + 0.2,
                  ];
                }
              });

              window.addEventListener("mouseleave", () => {
                pointers[0].down = false;
              });

              window.addEventListener("touchend", (e) => {
                const touches = e.changedTouches;
                for (let i = 0; i < touches.length; i++)
                  for (let j = 0; j < pointers.length; j++)
                    if (touches[i].identifier == pointers[j].id)
                      pointers[j].down = false;
              });
    </script> -->

    <!-- <script>
      document.addEventListener('DOMContentLoaded', function() {
          const text = "Tap, Earn & Rule the Bull Kingdom!";
          const container = document.getElementById('text-container');
          

          text.split('').forEach(char => {
              const span = document.createElement('span');
              span.textContent = char;
              span.classList.add('letter');
              container.appendChild(span);
          });

          const letters = document.querySelectorAll('.letter');
          const animationContainer = document.getElementById('animation-container');

          function lerp(start, end, amount) {
              return (1 - amount) * start + amount * end;
          }

          animationContainer.addEventListener('mousemove', (e) => {
              const mouseX = e.clientX;
              const mouseY = e.clientY;

              letters.forEach((letter) => {
                  const rect = letter.getBoundingClientRect();
                  const centerX = rect.left + rect.width / 2;
                  const centerY = rect.top + rect.height / 2;

                  const distanceX = mouseX - centerX;
                  const distanceY = mouseY - centerY;
                  const distance = Math.sqrt(distanceX ** 2 + distanceY ** 2);
                  const maxDistance = 200;

                  if (distance < maxDistance) {
                      const force = (maxDistance - distance) / maxDistance;
                      const moveX = lerp(0, distanceX, force * 0.5);
                      const moveY = lerp(0, distanceY, force * 0.5);
                      letter.style.transform = `translate(${moveX}px, ${moveY}px)`;
                      letter.style.transitionDuration = '0.2s';
                  } else {
                      letter.style.transform = 'translate(0, 0)';
                      letter.style.transitionDuration = '0.5s';
                  }
              });

              // cursor.style.left = `${mouseX}px`;
              // cursor.style.top = `${mouseY}px`;
          });

          animationContainer.addEventListener('mouseleave', () => {
              letters.forEach((letter) => {
                  letter.style.transform = 'translate(0, 0)';
                  letter.style.transitionDuration = '0.5s';
              });
          });
          
      });
    </script> -->

    <!-- <script>
      document.addEventListener('DOMContentLoaded', function () {
          const text = "Tap, Earn & Rule the Bull Kingdom!";
          const container = document.getElementById('text-container');

          // Split text into words and create spans for each word
          text.split(' ').forEach((word) => {
              const wordSpan = document.createElement('span');
              wordSpan.classList.add('word');

              if (word === 'Bull' || word === 'Kingdom!') {
                  wordSpan.classList.add('colored-text');
              }
              if (word === '&' || word === 'the') {
                  wordSpan.classList.add('sm-text');
              }
              
              word.split('').forEach((char) => {
                  const charSpan = document.createElement('span');
                  charSpan.textContent = char;
                  charSpan.classList.add('letter');
                  wordSpan.appendChild(charSpan);
              });

              container.appendChild(wordSpan);
              
              // Add a space after each word
              const space = document.createTextNode(' ');
              container.appendChild(space);
          });

          const letters = document.querySelectorAll('.letter');
          const animationContainer = document.getElementById('animation-container');

          function lerp(start, end, amount) {
              return (1 - amount) * start + amount * end;
          }

          animationContainer.addEventListener('mousemove', (e) => {
              const mouseX = e.clientX;
              const mouseY = e.clientY;

              letters.forEach((letter) => {
                  const rect = letter.getBoundingClientRect();
                  const centerX = rect.left + rect.width / 2;
                  const centerY = rect.top + rect.height / 2;

                  const distanceX = mouseX - centerX;
                  const distanceY = mouseY - centerY;
                  const distance = Math.sqrt(distanceX ** 2 + distanceY ** 2);
                  const maxDistance = 200;

                  if (distance < maxDistance) {
                      const force = (maxDistance - distance) / maxDistance;
                      const moveX = lerp(0, distanceX, force * 0.5);
                      const moveY = lerp(0, distanceY, force * 0.5);
                      letter.style.transform = `translate(${moveX}px, ${moveY}px)`;
                      letter.style.transitionDuration = '0.2s';
                  } else {
                      letter.style.transform = 'translate(0, 0)';
                      letter.style.transitionDuration = '0.5s';
                  }
              });
          });

          animationContainer.addEventListener('mouseleave', () => {
              letters.forEach((letter) => {
                  letter.style.transform = 'translate(0, 0)';
                  letter.style.transitionDuration = '0.5s';
              });
          });
      });
    </script> -->

    <script>
      document.addEventListener('DOMContentLoaded', function () {
          const lerp = (start, end, amount) => (1 - amount) * start + amount * end;

          // Function to create the animated effect for headings
          function animateHeading(element) {
              const text = element.textContent;
              const container = element;

              // Split text into words and create spans for each word
              element.innerHTML = ''; // Clear existing content
              text.split(' ').forEach((word) => {
                  const wordSpan = document.createElement('span');
                  wordSpan.classList.add('word');

                  if (word === 'Bull' && container.closest('.hero-section') || word === 'Kingdom!') {
                      wordSpan.classList.add('colored-text');
                  }
                  if (word === '&' && container.closest('.hero-section') || word === 'the') {
                      wordSpan.classList.add('sm-text');
                  }

                  word.split('').forEach((char) => {
                      const charSpan = document.createElement('span');
                      charSpan.textContent = char;
                      charSpan.classList.add('letter');
                      wordSpan.appendChild(charSpan);
                  });

                  container.appendChild(wordSpan);

                  // Add a space after each word
                  const space = document.createTextNode(' ');
                  container.appendChild(space);
              });

              const letters = container.querySelectorAll('.letter');

              container.addEventListener('mousemove', (e) => {
                  const mouseX = e.clientX;
                  const mouseY = e.clientY;

                  letters.forEach((letter) => {
                      const rect = letter.getBoundingClientRect();
                      const centerX = rect.left + rect.width / 2;
                      const centerY = rect.top + rect.height / 2;

                      const distanceX = mouseX - centerX;
                      const distanceY = mouseY - centerY;
                      const distance = Math.sqrt(distanceX ** 2 + distanceY ** 2);
                      const maxDistance = 200;

                      if (distance < maxDistance) {
                          const force = (maxDistance - distance) / maxDistance;
                          const moveX = lerp(0, distanceX, force * 0.5);
                          const moveY = lerp(0, distanceY, force * 0.5);
                          letter.style.transform = `translate(${moveX}px, ${moveY}px)`;
                          letter.style.transitionDuration = '0.2s';
                      } else {
                          letter.style.transform = 'translate(0, 0)';
                          letter.style.transitionDuration = '0.5s';
                      }
                  });
              });

              container.addEventListener('mouseleave', () => {
                  letters.forEach((letter) => {
                      letter.style.transform = 'translate(0, 0)';
                      letter.style.transitionDuration = '0.5s';
                  });
              });
          }

          // Apply animation to all headings with the class 'animated-heading'
          const headings = document.querySelectorAll('.animated-heading');
          headings.forEach(animateHeading);
      });



// Set the target date and time
const targetDate = new Date("January 16, 2025 06:00:00 UTC").getTime();

// Update the countdown every second
const countdown = setInterval(() => {
  const now = new Date().getTime();
  const timeLeft = targetDate - now;

  // Calculate time components
  const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
  const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
  const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

  // Update the HTML elements
  document.getElementById("days").innerText = days < 10 ? "0" + days : days;
  document.getElementById("hours").innerText = hours < 10 ? "0" + hours : hours;
  document.getElementById("minutes").innerText = minutes < 10 ? "0" + minutes : minutes;
  document.getElementById("seconds").innerText = seconds < 10 ? "0" + seconds : seconds;

  // Stop the countdown when time is up
  if (timeLeft < 0) {
    clearInterval(countdown);
    document.querySelector(".countdown").innerHTML = "<p>We're live now!</p>";
  }
}, 1000);


    </script>

    <!-- cursor js -->
     <!-- <script>

      let trails = []; // To store trail elements
      let idleTrail; // To store the persistent idle trail element
      let timeoutId; // To store timeout for idle state

      document.addEventListener("mousemove", (event) => {
        // Create a trail element for the mouse movement
        const trail = document.createElement("div");
        trail.className = "trail";
        document.body.appendChild(trail);

        // Set the trail's position based on mouse coordinates
        trail.style.left = `${event.pageX - trail.offsetWidth / 2}px`;
        trail.style.top = `${event.pageY - trail.offsetHeight / 2}px`;

        // Remove the trail element after animation ends
        trails.push(trail);
        setTimeout(() => {
          trail.remove();
          trails = trails.filter(item => item !== trail);
        }, 600); // Matches animation duration

        // Create the persistent glowing circle when the cursor moves
        if (!idleTrail) {
          idleTrail = document.createElement("div");
          idleTrail.className = "trail"; // Using the same "trail" class for animation
          document.body.appendChild(idleTrail);
        }

        // Update the position of the persistent idle trail to follow the cursor
        idleTrail.style.left = `${event.pageX - idleTrail.offsetWidth / 2}px`;
        idleTrail.style.top = `${event.pageY - idleTrail.offsetHeight / 2}px`;

        // Reset animation to apply it every time the mouse moves
        idleTrail.style.animation = "none";
        idleTrail.offsetHeight; // Trigger reflow to reset animation
        idleTrail.style.animation = "trailMovement 0.6s ease-out forwards"; // Reapply animation

        // Clear the timeout if the cursor is moving
        clearTimeout(timeoutId);

        // Set a timeout to hide the idle trail if the cursor is idle for 1 second
        timeoutId = setTimeout(() => {
          idleTrail.style.animation = "none"; // Stop animation when idle
        }, 1000); // Set idle time (1 second)
      });

      // Optional: If you want to clear the idle trail after some time, you can remove it
      // setTimeout(() => {
      //   if (idleTrail) {
      //     idleTrail.remove();
      //   }
      // }, 1000);


     </script> -->

     <script>
        let trails = []; // Store all trail elements
        let lastPosition = { x: null, y: null }; // Store the last position
        let idleTrail; // Persistent idle trail
        let timeoutId; // Timeout to track idle state

        function handleIdleTrailVisibility() {
          if (window.innerWidth < 992) {
            // Hide the idle trail if it exists
            if (idleTrail) idleTrail.style.display = "none";
          } else {
            // Show the idle trail
            if (idleTrail) idleTrail.style.display = "block";
          }
        }

        // Run the visibility check when the page loads or resizes
        window.addEventListener("resize", handleIdleTrailVisibility);
        document.addEventListener("DOMContentLoaded", handleIdleTrailVisibility);

        document.addEventListener("mousemove", (event) => {
          // Check if last position exists
          if (lastPosition.x !== null && lastPosition.y !== null) {
            // Calculate distance between last position and current position
            const distanceX = event.pageX - lastPosition.x;
            const distanceY = event.pageY - lastPosition.y;
            const distance = Math.sqrt(distanceX ** 2 + distanceY ** 2);

            // Fill the gap by creating additional trails
            const trailCount = Math.ceil(distance / 5); // Adjust the gap by changing divisor (5)
            for (let i = 0; i < trailCount; i++) {
              const x = lastPosition.x + (distanceX / trailCount) * i;
              const y = lastPosition.y + (distanceY / trailCount) * i;

              createTrail(x, y);
            }
          }

          // Create trail at the current mouse position
          createTrail(event.pageX, event.pageY);

          // Update last position
          lastPosition = { x: event.pageX, y: event.pageY };

          // Handle idle trail
          if (!idleTrail) {
            idleTrail = document.createElement("div");
            idleTrail.className = "trail";
            document.body.appendChild(idleTrail);
          }
          idleTrail.style.left = `${event.pageX - idleTrail.offsetWidth / 2}px`;
          idleTrail.style.top = `${event.pageY - idleTrail.offsetHeight / 2}px`;

          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => {
            idleTrail.style.animation = "none"; // Stop animation
          }, 1000);
        });

        // Function to create a trail element
        function createTrail(x, y) {
          const trail = document.createElement("div");
          trail.className = "trail";
          trail.style.left = `${x}px`;
          trail.style.top = `${y}px`;
          document.body.appendChild(trail);

          // Remove trail after animation ends
          setTimeout(() => {
            trail.remove();
          }, 600); // Matches animation duration
        }

     </script>

  </body>
</html>
